//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool
//     Changes to this file will be lost if the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System.Globalization;
using System.IO;

namespace Tako.Modbus.Client
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Text;

    internal abstract class AbsModbusRequest
    {
        private ModbusUtility _modbusUtility = new ModbusUtility();

        protected ModbusUtility ModbusUtility
        {
            get { return _modbusUtility; }
            set { _modbusUtility = value; }
        }

        public virtual ushort? TransactionID { get; set; }

        protected virtual void QuantityValidate(ushort StartAddress, ushort Quantity, ushort MinQuantity, ushort MaxQuantity)
        {
            if (Quantity < MinQuantity || Quantity > MaxQuantity)
            {
                throw ModbusException.GetModbusException(0x03);
            }
        }

        protected virtual byte GetMultiOutputCount(ushort Quantity)
        {
            byte i = (byte)(Quantity / 8);
            byte j = (byte)(Quantity - (i * 8));

            byte counter = 0;
            if (j == 0)
            {
                counter = i;
            }
            else
            {
                counter = (byte)(i + 1);
            }

            return counter;
        }

        protected virtual byte[] GetMultiOutputCount(short[] OutputValues)
        {
            byte counter = 0;
            byte[] outputArray = null;

            using (MemoryStream stream = new MemoryStream())
            {
                foreach (var output in OutputValues)
                {
                    var tempArray = BitConverter.GetBytes((short)output);
                    Array.Reverse(tempArray);
                    stream.Write(tempArray, 0, tempArray.Length);
                    counter += (byte)tempArray.Length;
                }

                outputArray = stream.ToArray();
            }
            return outputArray;
        }

        protected abstract byte[] CreateRequestMessage(byte Unit, EnumModbusFunctionCode FunctionCode, byte? MultiOutputLength, params byte[] Parameters);

        public virtual byte[] ReadCoils(byte Unit, ushort StartAddress, ushort Quantity)
        {
            this.QuantityValidate(StartAddress, Quantity, 1, 2000);

            var parameters = new byte[]
            {
                (byte)(StartAddress >> 8),
                (byte)(StartAddress),
                (byte)(Quantity >> 8),
                (byte)Quantity
            };
            var requestArray = this.CreateRequestMessage(Unit, EnumModbusFunctionCode.ReadCoils, null, parameters);
            return requestArray;
        }

        public virtual byte[] ReadDiscreteInputs(byte Unit, ushort StartAddress, ushort Quantity)
        {
            this.QuantityValidate(StartAddress, Quantity, 1, 2000);

            var parameters = new byte[]
            {
                (byte)(StartAddress >> 8),
                (byte)(StartAddress),
                (byte)(Quantity >> 8),
                (byte)Quantity
            };
            var requestArray = this.CreateRequestMessage(Unit, EnumModbusFunctionCode.ReadDiscreteInputs, null, parameters);
            return requestArray;
        }

        public virtual byte[] ReadHoldingRegisters(byte Unit, ushort StartAddress, ushort Quantity)
        {
            this.QuantityValidate(StartAddress, Quantity, 1, 175);

            var parameters = new byte[]
            {
                (byte)(StartAddress >> 8),
                (byte)(StartAddress),
                (byte)(Quantity >> 8),
                (byte)Quantity
            };
            var requestArray = this.CreateRequestMessage(Unit, EnumModbusFunctionCode.ReadHoldingRegisters, null, parameters);
            return requestArray;
        }

        public virtual byte[] ReadInputRegisters(byte Unit, ushort StartAddress, ushort Quantity)
        {
            this.QuantityValidate(StartAddress, Quantity, 1, 175);

            var parameters = new byte[]
            {
                (byte)(StartAddress >> 8),
                (byte)(StartAddress),
                (byte)(Quantity >> 8),
                (byte)Quantity
            };
            var requestArray = this.CreateRequestMessage(Unit, EnumModbusFunctionCode.ReadInputRegisters, null, parameters);
            return requestArray;
        }

        public virtual byte[] WriteSingleCoil(byte Unit, ushort OutputAddress, bool OutputValue)
        {
            ushort outputValue = 0x0000;
            if (OutputValue)
            {
                outputValue = 0xFF00;
            }

            var parameters = new byte[]
            {
                (byte)(OutputAddress >> 8),
                (byte)(OutputAddress),
                (byte)(outputValue >> 8),
                (byte)(outputValue),
            };
            var requestArray = this.CreateRequestMessage(Unit, EnumModbusFunctionCode.WriteSingleCoil, null, parameters);
            return requestArray;
        }

        public virtual byte[] WriteSingleRegister(byte Unit, ushort OutputAddress, short OutputValue)
        {
            var parameters = new byte[]
            {
                (byte)(OutputAddress >> 8),
                (byte)(OutputAddress),
                (byte)(OutputValue >> 8),
                (byte)(OutputValue),
            };
            var requestArray = this.CreateRequestMessage(Unit, EnumModbusFunctionCode.WriteSingleRegister, null, parameters);
            return requestArray;
        }

        public virtual byte[] WriteMultipleCoils(byte Unit, ushort StartAddress, ushort Quantity, byte[] OutputValues)
        {
            this.QuantityValidate(StartAddress, Quantity, 1, 0x07B0);

            byte counter = this.GetMultiOutputCount(Quantity);

            if (counter != OutputValues.Length)
            {
                ModbusException.GetModbusException(0x03);
            }

            using (MemoryStream memoryStream = new MemoryStream())
            {
                memoryStream.WriteByte((byte)(StartAddress >> 8));
                memoryStream.WriteByte((byte)(StartAddress));
                memoryStream.WriteByte((byte)(Quantity >> 8));
                memoryStream.WriteByte((byte)(Quantity));
                memoryStream.WriteByte((byte)(counter));
                memoryStream.Write(OutputValues, 0, OutputValues.Length);
                var requestArray = this.CreateRequestMessage(Unit, EnumModbusFunctionCode.WriteMultipleCoils, (byte)OutputValues.Length, memoryStream.ToArray());
                return requestArray;
            }
        }

        public virtual byte[] WriteMultipleRegisters(byte Unit, ushort StartAddress, ushort Quantity, short[] OutputValues)
        {
            this.QuantityValidate(StartAddress, Quantity, 1, 0x007B);

            byte[] outputArray = this.GetMultiOutputCount(OutputValues);
            byte counter = (byte)outputArray.Length;

            if (Quantity * 2 != outputArray.Length)
            {
                ModbusException.GetModbusException(0x02);
            }

            using (MemoryStream memoryStream = new MemoryStream())
            {
                memoryStream.WriteByte((byte)(StartAddress >> 8));
                memoryStream.WriteByte((byte)(StartAddress));
                memoryStream.WriteByte((byte)(Quantity >> 8));
                memoryStream.WriteByte((byte)(Quantity));
                memoryStream.WriteByte((byte)(counter));
                memoryStream.Write(outputArray, 0, outputArray.Length);
                var requestArray = this.CreateRequestMessage(Unit, EnumModbusFunctionCode.WriteMultipleRegisters, (byte)outputArray.Length, memoryStream.ToArray());
                return requestArray;
            }
        }
    }
}