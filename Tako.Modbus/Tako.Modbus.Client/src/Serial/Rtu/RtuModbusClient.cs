//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool
//     Changes to this file will be lost if the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System.Diagnostics;
using System.IO.Ports;

namespace Tako.Modbus.Client
{
    using System;
    using System.Collections.Generic;
    using System.IO;
    using System.Linq;
    using System.Text;
    using System.Threading;

    public class RtuModbusClient : AbsModbusClient
    {
        private AbsModbusRequest _modbusRequest = new RtuModbusRequest();
        private AbsModbusResponse _modbusResponse = new RtuModbusResponse();
        private AbsModbusDataConvert _modbusDataConvert = new HexModbusDataConvert();

        public SerialPort ModbusSerialPort { get; set; }

        public override bool Connect<T>(T ConnectConfig)
        {
            if (ConnectConfig == null)
            {
                throw new ArgumentNullException("ConnectConfig");
            }

            SerialModbusConnectConifg connectConfig = ConnectConfig as SerialModbusConnectConifg;
            if (connectConfig == null)
            {
                throw new NotSupportedException("ConnectConfig");
            }
            if (this.ModbusSerialPort == null)
            {
                this.ModbusSerialPort = new SerialPort(connectConfig.PortName, connectConfig.BaudRate, connectConfig.Parity, connectConfig.DataBits, connectConfig.StopBits);
            }

            if (this.ModbusSerialPort.IsOpen)
            {
                this.ModbusSerialPort.Close();
                Thread.Sleep(100);
            }

            this.ModbusSerialPort.Open();
            this.IsConnected = this.ModbusSerialPort.IsOpen;
            return this.IsConnected;
        }

        internal override AbsModbusRequest ModbusRequest
        {
            get { return _modbusRequest; }
            set { _modbusRequest = value; }
        }

        internal override AbsModbusResponse ModbusResponse
        {
            get { return _modbusResponse; }
            set { _modbusResponse = value; }
        }

        internal override AbsModbusDataConvert ModbusDataConvert
        {
            get { return _modbusDataConvert; }
            set { _modbusDataConvert = value; }
        }

        public override bool Disconnect()
        {
            if (!this.IsConnected)
            {
                return false;
            }
            this.ModbusSerialPort.Close();
            this.IsConnected = this.ModbusSerialPort.IsOpen;
            return !this.IsConnected;
        }

        public override byte[] Receive()
        {
            if (!this.IsConnected)
            {
                throw new ModbusException("No Connect");
            }
            var timeoutTemp = this.ModbusSerialPort.ReadTimeout;
            this.ModbusSerialPort.ReadTimeout = this.ReceiveTimeout;
            byte[] bufferArray = new byte[256];
            byte[] resultArray = null;
            var retryTime = 0;

            using (MemoryStream stream = new MemoryStream())
            {
                while (true)
                {
                    if (this.ModbusSerialPort.BytesToRead > 0)
                    {
                        var receiveCount = this.ModbusSerialPort.Read(bufferArray, 0, bufferArray.Length);
                        stream.Write(bufferArray, 0, receiveCount);
                        resultArray = stream.ToArray();
                        if (receiveCount <= 0)
                        {
                            break;
                        }

                        retryTime = 0;
                    }
                    retryTime++;
                    if (retryTime > this.RetryTime)
                    {
                        break;
                    }

                    //空轉
                    SpinWait.SpinUntil(() => retryTime > this.RetryTime, this.RetryTimeInterval);
                }
            }

            if (resultArray == null || resultArray.Length == 0)
            {
                throw new ModbusException("Receive Timeout");
            }
            this.ModbusSerialPort.ReadTimeout = timeoutTemp;
            return resultArray;
        }

        public override bool Send(byte[] RequestArray)
        {
            this.ModbusSerialPort.Write(RequestArray, 0, RequestArray.Length);
            return true;
        }

        public override void Dispose()
        {
            this.Dispose(true);
            GC.SuppressFinalize(this);
        }

        ~RtuModbusClient()
        {
            Dispose(false);
        }

        protected virtual void Dispose(bool disposing)
        {
            if (this.Disposed)
                return;

            this.IsConnected = false;

            if (disposing)
            {
                //clean management resource
                if (this.ModbusSerialPort != null)
                {
                    this.ModbusSerialPort.Dispose();
                    this.ModbusSerialPort = null;
                }
            }

            //clean unmanagement resource

            //change flag
            this.Disposed = true;
        }
    }
}