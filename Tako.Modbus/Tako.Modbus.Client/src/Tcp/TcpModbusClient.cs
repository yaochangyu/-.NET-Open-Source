//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool
//     Changes to this file will be lost if the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System.Diagnostics;
using System.IO;
using System.Net;
using System.Net.Sockets;
using System.Threading;

namespace Tako.Modbus.Client
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Text;

    public class TcpModbusClient : AbsModbusClient
    {
        private AbsModbusRequest _modbusRequest = new TcpModbusRequest();
        private AbsModbusResponse _modbusResponse = new TcpModbusResponse();
        private AbsModbusDataConvert _modbusDataConvert = new HexModbusDataConvert();

        private Socket ModbusClient { get; set; }

        private IPEndPoint ModbusEndPoint { get; set; }

        public override bool Connect<T>(T ConnectConfig)
        {
            if (ConnectConfig == null)
            {
                throw new ArgumentNullException("ConnectConfig");
            }

            TcpModbusConnectConfig connectConfig = ConnectConfig as TcpModbusConnectConfig;
            if (connectConfig == null)
            {
                throw new NotSupportedException("ConnectConfig");
            }
            if (this.ModbusClient == null)
            {
                this.ModbusClient = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
            }

            this.ModbusEndPoint = new IPEndPoint(IPAddress.Parse(connectConfig.IpAddress), connectConfig.Port);

            this.ModbusClient.Connect((EndPoint)ModbusEndPoint);
            this.IsConnected = this.ModbusClient.Connected;
            return this.IsConnected;
        }

        internal override AbsModbusRequest ModbusRequest
        {
            get { return _modbusRequest; }
            set { _modbusRequest = value; }
        }

        internal override AbsModbusResponse ModbusResponse
        {
            get { return _modbusResponse; }
            set { _modbusResponse = value; }
        }

        internal override AbsModbusDataConvert ModbusDataConvert
        {
            get { return _modbusDataConvert; }
            set { _modbusDataConvert = value; }
        }

        public override bool Disconnect()
        {
            if (!this.IsConnected)
            {
                return false;
            }

            this.ModbusClient.Shutdown(SocketShutdown.Both);
            this.ModbusClient.Disconnect(false);
            this.IsConnected = this.ModbusClient.Connected;
            return !this.IsConnected;
        }

        public override bool Send(byte[] RequestArray)
        {
            if (!this.connectVerify())
            {
                return false;
            }
            this.ModbusClient.Send(RequestArray);
            return true;
        }

        public override byte[] Receive()
        {
            if (!this.connectVerify())
            {
                return null;
            }

            var tempTimeOut = this.ModbusClient.ReceiveTimeout;
            this.ModbusClient.ReceiveTimeout = this.ReceiveTimeout;

            var bufferArray = new byte[256];
            var socketError = new SocketError();
            byte[] responseArray = null;

            var retrTime = 0;

            using (MemoryStream memory = new MemoryStream())
            {
                while (true)
                {
                    if (this.ModbusClient.Available > 0)
                    {
                        var receiveCount = this.ModbusClient.Receive(bufferArray, 0, bufferArray.Length, SocketFlags.None, out socketError);
                        if (receiveCount == 0 || socketError != SocketError.Success)
                        {
                            break;
                        }
                        memory.Write(bufferArray, 0, receiveCount);

                        retrTime = 0;
                    }

                    retrTime++;

                    if (retrTime > this.RetryTime)
                    {
                        break;
                    }

                    //空轉
                    SpinWait.SpinUntil(() => retrTime > this.RetryTime, this.RetryTimeInterval);
                }

                this.ModbusClient.ReceiveTimeout = tempTimeOut;
                responseArray = memory.ToArray();
            }

            if (responseArray == null || responseArray.Length == 0)
            {
                throw new ModbusException("Receive reponse timeout");
            }
            return responseArray;
        }

        public override void Dispose()
        {
            this.Dispose(true);
            GC.SuppressFinalize(this);
        }

        ~TcpModbusClient()
        {
            Dispose(false);
        }

        protected virtual void Dispose(bool disposing)
        {
            if (this.Disposed)
                return;

            this.IsConnected = false;

            if (disposing)
            {
                //clean management resource
                if (this.ModbusClient != null)
                {
                    this.ModbusClient.Shutdown(SocketShutdown.Both);
                    this.ModbusClient.Disconnect(false);
                    this.ModbusClient.Dispose();
                    this.ModbusClient = null;
                }
            }

            //clean unmanagement resource

            //change flag
            this.Disposed = true;
        }

        private bool connectVerify()
        {
            if (!this.IsConnected)
            {
                throw new Exception("No Connect");
            }
            if (this.Disposed)
            {
                return false;
            }
            return true;
        }
    }
}